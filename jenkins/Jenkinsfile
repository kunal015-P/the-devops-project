pipeline {
    agent any
    
    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        ECR_REPOSITORY = '${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/devops-flask-app-flask-app'
        KUBECONFIG = '/var/lib/jenkins/.kube/config'
        IMAGE_TAG = "${BUILD_NUMBER}"
        APP_NAME = 'flask-app'
        NAMESPACE = 'default'
    }
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Target environment for deployment'
        )
        booleanParam(
            name: 'DEPLOY_TO_K8S',
            defaultValue: true,
            description: 'Deploy to Kubernetes cluster'
        )
        booleanParam(
            name: 'RUN_TESTS',
            defaultValue: true,
            description: 'Run unit tests before deployment'
        )
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_HASH = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()
                    env.IMAGE_TAG = "${BUILD_NUMBER}-${env.GIT_COMMIT_HASH}"
                }
            }
        }
        
        stage('Setup Environment') {
            steps {
                script {
                    // Get AWS Account ID
                    env.AWS_ACCOUNT_ID = sh(
                        script: 'aws sts get-caller-identity --query Account --output text',
                        returnStdout: true
                    ).trim()
                    
                    // Update ECR repository URL
                    env.ECR_REPOSITORY = "${env.AWS_ACCOUNT_ID}.dkr.ecr.${env.AWS_DEFAULT_REGION}.amazonaws.com/devops-flask-app-flask-app"
                    
                    echo "AWS Account ID: ${env.AWS_ACCOUNT_ID}"
                    echo "ECR Repository: ${env.ECR_REPOSITORY}"
                    echo "Image Tag: ${env.IMAGE_TAG}"
                }
            }
        }
        
        stage('Build Application') {
            steps {
                echo 'Building Flask application...'
                dir('app') {
                    sh '''
                        python3 -m venv venv
                        source venv/bin/activate
                        pip install -r requirements.txt
                    '''
                }
            }
        }
        
        stage('Run Tests') {
            when {
                params.RUN_TESTS == true
            }
            steps {
                echo 'Running unit tests...'
                dir('app') {
                    sh '''
                        source venv/bin/activate
                        python -m pytest tests/ || echo "No tests found, skipping..."
                        python -m flake8 . --max-line-length=100 || echo "Linting warnings found"
                    '''
                }
            }
            post {
                always {
                    // Publish test results if available
                    publishTestResults testResultsPattern: 'app/test-results.xml'
                }
            }
        }
        
        stage('Security Scan') {
            steps {
                echo 'Running security scan...'
                dir('app') {
                    sh '''
                        source venv/bin/activate
                        pip install safety bandit
                        safety check || echo "Security warnings found"
                        bandit -r . -f json -o bandit-report.json || echo "Bandit scan completed with warnings"
                    '''
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'app/bandit-report.json', allowEmptyArchive: true
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo 'Building Docker image...'
                script {
                    def dockerImage = docker.build("${env.ECR_REPOSITORY}:${env.IMAGE_TAG}")
                    env.DOCKER_IMAGE_ID = dockerImage.id
                }
            }
        }
        
        stage('Push to ECR') {
            steps {
                echo 'Pushing image to ECR...'
                script {
                    // Login to ECR
                    sh '''
                        aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | \
                        docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com
                    '''
                    
                    // Push image
                    sh '''
                        docker push ${ECR_REPOSITORY}:${IMAGE_TAG}
                        docker tag ${ECR_REPOSITORY}:${IMAGE_TAG} ${ECR_REPOSITORY}:latest
                        docker push ${ECR_REPOSITORY}:latest
                    '''
                }
            }
        }
        
        stage('Update Kubernetes Manifests') {
            when {
                params.DEPLOY_TO_K8S == true
            }
            steps {
                echo 'Updating Kubernetes manifests...'
                sh '''
                    # Replace placeholders in Kubernetes manifests
                    sed -i "s|\${ECR_REPOSITORY_URI}|${ECR_REPOSITORY}|g" k8s/flask-app-deployment.yaml
                    sed -i "s|\${IMAGE_TAG}|${IMAGE_TAG}|g" k8s/flask-app-deployment.yaml
                    
                    # Validate Kubernetes manifests
                    kubectl --dry-run=client -f k8s/ validate || echo "Validation warnings found"
                '''
            }
        }
        
        stage('Deploy to Kubernetes') {
            when {
                params.DEPLOY_TO_K8S == true
            }
            steps {
                echo "Deploying to Kubernetes cluster (${params.ENVIRONMENT})..."
                script {
                    // Update kubeconfig for EKS
                    sh '''
                        aws eks update-kubeconfig --region ${AWS_DEFAULT_REGION} --name devops-flask-cluster
                        kubectl get nodes
                    '''
                    
                    // Deploy application
                    sh '''
                        kubectl apply -f k8s/flask-app-deployment.yaml
                        kubectl apply -f k8s/flask-app-ingress.yaml
                        kubectl apply -f k8s/flask-app-hpa.yaml
                        
                        # Wait for deployment to complete
                        kubectl rollout status deployment/${APP_NAME} -n ${NAMESPACE} --timeout=300s
                        
                        # Verify deployment
                        kubectl get pods -l app=${APP_NAME} -n ${NAMESPACE}
                        kubectl get services -l app=${APP_NAME} -n ${NAMESPACE}
                    '''
                }
            }
        }
        
        stage('Run Smoke Tests') {
            when {
                params.DEPLOY_TO_K8S == true
            }
            steps {
                echo 'Running smoke tests...'
                script {
                    sh '''
                        # Get service endpoint
                        SERVICE_IP=$(kubectl get service flask-app-service -n ${NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "pending")
                        
                        if [ "$SERVICE_IP" != "pending" ] && [ "$SERVICE_IP" != "" ]; then
                            echo "Testing application at http://$SERVICE_IP"
                            curl -f http://$SERVICE_IP/health || echo "Health check failed"
                        else
                            echo "Service IP not available yet, testing via port-forward"
                            kubectl port-forward service/flask-app-service 8080:80 -n ${NAMESPACE} &
                            sleep 10
                            curl -f http://localhost:8080/health || echo "Health check failed"
                            pkill -f "kubectl port-forward" || true
                        fi
                    '''
                }
            }
        }
    }
    
    post {
        always {
            echo 'Pipeline completed!'
            // Clean up Docker images
            sh '''
                docker rmi ${ECR_REPOSITORY}:${IMAGE_TAG} || true
                docker rmi ${ECR_REPOSITORY}:latest || true
                docker system prune -f || true
            '''
        }
        success {
            echo 'Pipeline succeeded!'
            // Send success notification (configure as needed)
            script {
                if (params.DEPLOY_TO_K8S == true) {
                    sh '''
                        echo "Deployment successful!" 
                        kubectl get deployment ${APP_NAME} -n ${NAMESPACE}
                    '''
                }
            }
        }
        failure {
            echo 'Pipeline failed!'
            // Send failure notification (configure as needed)
            script {
                sh '''
                    echo "Pipeline failed. Check logs for details."
                    kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp' | tail -10
                '''
            }
        }
    }
}